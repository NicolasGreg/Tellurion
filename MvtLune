void LaLune() {

  float p = 4.9085+(0.00000081856)*NbJour;
  LongSolMoy = 4.8689+(.0172027914)*NbJour;
  float  mSol = LongSolMoy-p;
  float LongMoyLu = .57999+.229971503*NbJour;
  float o = 4.1867-(.00092422)*NbJour;
  float m = .3193+.228027135*NbJour;
  float D = LongMoyLu-LongSolMoy;
  float f = LongMoyLu-o;
  float l = LongMoyLu+.1098*sin(m)+.003728*sin(2*m)+.01149*sin(2*D);
  l = l-.003329*sin(mSol)+.02224*sin(D-m)-.001945*sin(2*f);
  l = l+.001026*sin(2*D-2*m)+0.00099829*sin(2*D-m-mSol);
  l = l+0.000990299*sin(2*D+m)+.0008011*sin(2*D-mSol);
  LongLune = l+.0007156*sin(m-mSol)-.0005323*sin(m+mSol)-.0006074*sin(D); 
  LongLune = LongLune % (2*PI); 
  stepLune=floor(map(LongLune, 0, 2*PI, 0, 2560));
  // On calcule de combien doit avancer le moteur par rapport à
  // l'avance précédente 
  currentStepLune=stepLune-previousStepLune;
  //Pour le passage de 12h à 0h
  if (currentStepLune<0) {
    currentStepLune=2560+currentStepLune;
  }
  if (currentStepLune>0) {
    previousStepLune=stepLune;
  }
  int count=0;
  while ( count<currentStepLune) {  
    fl=fl-(2*PI/2560);
    count++;
  }
  //println(fl);
  xl1 = round(xl*cos( fl) - yl*sin( fl));
  yl1 = round(yl*cos( fl) + xl*sin( fl));
}

float PositionSoleil() {

  float p = 4.9085+(0.00000081856)*NbJour;
  LongSolMoy = 4.8689+(.0172027914)*NbJour;
  float  m = LongSolMoy-p;
  mSol = m;
  u = EquationDeKepler(m, .01675104, 4); 
  float v = sqrt((1+.01675104)/(1-.01675104))*tan(u/2);
  v = 2*atan(v);
  float LongSol = v+p;
  LongSol = LongSol % (2*PI); 
  xsv1 = round(xsv*cos( -LongSol) - ysv*sin( -LongSol));
  ysv1 = round(ysv*cos( -LongSol) + xsv*sin( -LongSol));
  return LongSol;
}

float EquationDeKepler(float m, float eccentricite, int ke) {
  u = m;
  for (int k=0; k<ke; k++) {
    u = m+eccentricite*sin(u);
  }
  return u;
}
