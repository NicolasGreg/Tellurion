void FonctionHorloge() {
  int h=hour();
  int s=second();
  if (h>=12) {
    h=h-12;
  }
  int m=minute();

  // 2048 pour un tour en une heure
  heure=(h+float(m)/60);
  int stepFH=floor(map(heure, 0, 12, 0, 512));
  //if (stepFH>2047) {
  //  stepFH=stepFH%2048;
  //}
  //if (start) {
  //  println("yes");
  //  previousStep= stepFH ; 
  //  start=false;
  //}

  // On calcule de combien doit avancer le moteur par rapport à
  // l'avance précédente 
  currentStep=stepFH-previousStep;
  //Pour le passage de 12h à 0h
  if (currentStep<0) {
    currentStep=512+currentStep;
  }
  println("Step : "+step+"   "+currentStep+" ");

  if (currentStep>0) {
    previousStep=stepFH;
    //String PS = str(previousStep);
    //String[] list =split(PS, ' ');
    //saveStrings("LastPosition.txt", list);
  }
  count=0;
  while ( count<currentStep) {

    // delay(200 );
    for (step=0; step<4; step++) {


      switch(step) { 
      case 0:
        GPIO.digitalWrite(controlPin[0], GPIO.HIGH);   
        GPIO.digitalWrite(controlPin[1], GPIO.HIGH); 
        GPIO.digitalWrite(controlPin[2], GPIO.LOW); 
        GPIO.digitalWrite(controlPin[3], GPIO.LOW); 
        break;  
      case 1:
        GPIO.digitalWrite(controlPin[0], GPIO.LOW);   
        GPIO.digitalWrite(controlPin[1], GPIO.HIGH); 
        GPIO.digitalWrite(controlPin[2], GPIO.HIGH); 
        GPIO.digitalWrite(controlPin[3], GPIO.LOW); 
        break;  
      case 2:
        GPIO.digitalWrite(controlPin[0], GPIO.LOW);   
        GPIO.digitalWrite(controlPin[1], GPIO.LOW); 
        GPIO.digitalWrite(controlPin[2], GPIO.HIGH); 
        GPIO.digitalWrite(controlPin[3], GPIO.HIGH); 
        break;  
      case 3:
        GPIO.digitalWrite(controlPin[0], GPIO.HIGH);   
        GPIO.digitalWrite(controlPin[1], GPIO.LOW); 
        GPIO.digitalWrite(controlPin[2], GPIO.LOW); 
        GPIO.digitalWrite(controlPin[3], GPIO.HIGH); 

        break;

        //if (seq[step][pin]==1) {
        //  GPIO.digitalWrite(controlPin[pin], GPIO.HIGH);
        //} else {
        //  GPIO.digitalWrite(controlPin[pin], GPIO.LOW);
        ////}
      }
      delay(100 );
    }
    count++;
    totalCount++;
  }

  //Remise à zero des pin pour éviter l'échauffement du moteur
  for (int pin=0; pin<4; pin++) {   
    GPIO.digitalWrite(controlPin[pin], GPIO.LOW);
  }
  ms=millis();
}

